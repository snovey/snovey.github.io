<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>雨雪霏霏</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.snovey.com/"/>
  <updated>2016-09-29T08:13:49.171Z</updated>
  <id>www.snovey.com/</id>
  
  <author>
    <name>雨雪霏霏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 对象作为函数参数的传递方式</title>
    <link href="www.snovey.com/2016/09/call-by-value/"/>
    <id>www.snovey.com/2016/09/call-by-value/</id>
    <published>2016-09-29T05:03:25.000Z</published>
    <updated>2016-09-29T08:13:49.171Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>All function arguments in ECMAScript are passed by value.<br><span style="display:block;text-align:right;"><em>Professional JavaScript for Web Developers, 3rd Edition</em></span></p>
</blockquote>
<a id="more"></a>
<p>不要单纯的根据上面这句话就认为 JavaScript 中的对象是按值传递（call by value）的，因为执行这段代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  x.item = <span class="string">"changed"</span>;</div><div class="line">  y = &#123;item: <span class="string">"changed"</span>&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj1 = &#123;item: <span class="string">"unchanged"</span>&#125;;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;item: <span class="string">"unchanged"</span>&#125;;</div><div class="line"></div><div class="line">change(obj1, obj2);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj1.item);  <span class="comment">//changed</span></div><div class="line"><span class="built_in">console</span>.log(obj2.item);  <span class="comment">//unchanged</span></div></pre></td></tr></table></figure></p>
<p>如果是纯粹的按值传递，那么函数内部的修改不会影响外部对象，应该都输出 <code>unchanged</code> 的才对，如果是按引用传递，那么二者都应该保持     <code>unchanged</code> 才对。</p>
<p>确切的说，JavaScript 中的基本类型值（primitive type）是按值传递的，引用类型值（Object type）是<strong>按共享传递（call by sharing）</strong>的。</p>
<p>这里补充一下 JavaScript 的内存分配方式，基本类型值是在栈空间分配的内存，而引用类型值则是在堆空间分配的内存，然后在栈空间分配一个指向对象的指针。在把对象作为参数传入函数时，会将指向对象的指针进行复制然后传递过去（不是直接传递的指针！），这样当对对象进行修改时，会改变对象，这就是 <code>obj1.item</code> 被改变的原因，而 <code>y = {item: &quot;changed&quot;};</code> 则是改变了指针的指向，也就与原来的对象无关了，所以 <code>obj1.item</code> 未被改变。更多信息请查看<a href="http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 8. Evaluation strategy.</a></p>
<p>反过来看红宝书错了么？红宝书在这句话之后进行了解释，作者认为传递拷贝之后的对象地址也是一种传值。所以请理解作者要传达的思想。</p>
<p>JavaScript 坑比较多，学习的时候最好找点靠谱的书和文档，有些人不懂还一本正经的瞎 BB，<!--像 [这样](http://www.cnblogs.com/Mblog/archive/2009/12/24/1631215.html)、[这样](http://www.zhihu.com/question/21673545)-->小心被带沟里去。<br>参考：</p>
<ul>
<li><a href="http://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language" target="_blank" rel="external">Is JavaScript a pass-by-reference or pass-by-value language?</a></li>
<li>Professional JavaScript for Web Developers, 3rd Edition</li>
</ul>
<blockquote>版权声明<br><hr>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by/4.0/" target="_blank">自由转载-非商用-非衍生-保持署名（知识共享署名 4.0 国际许可协议）</a>进行许可。<br>本文链接：www.snovey.com/2016/09/call-by-value/</blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;All function arguments in ECMAScript are passed by value.&lt;br&gt;&lt;span style=&quot;display:block;text-align:right;&quot;&gt;&lt;em&gt;Professional JavaScript for Web Developers, 3rd Edition&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="www.snovey.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="www.snovey.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于 STL 中迭代器的一点思考</title>
    <link href="www.snovey.com/2016/09/STL-iterator/"/>
    <id>www.snovey.com/2016/09/STL-iterator/</id>
    <published>2016-09-27T06:06:28.000Z</published>
    <updated>2016-09-29T07:45:18.354Z</updated>
    
    <content type="html"><![CDATA[<p>我第一个接触的容器是 vector，当时遍历容器的写法是这样的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//TODO</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>后来看到别人的写法是这样的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//TODO</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>觉得既然 STL 既然内置了 iterator，应该有它自己的优势，虽然这两种写法的时间复杂度都是 O(n)。<br>那么它们的具体区别是什么呢？在我闲逛 stackoverflow 时看到了相关的讨论，这两种方式在遍历 vector 时并无区别，但是第一种方法却不一定适用于其它容器，例如 map，而且后者也易于理解，从维护性，复用性等角度来看都是后者更具备优势。<br>在 STL 中还有反向迭代器，可以反序遍历容器，像这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator it = v.rbegin(); it != v.rend(); it++)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//TODO</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里反向迭代器将 <code>++</code> 与 <code>--</code> 的含义反了过来，<code>++</code> 访问前一个元素，而 <code>--</code> 访问后一个元素。<br>但是为什么不像下面这样遍历呢？<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator rit = v.end(); rit != v.begin(); rit++)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//TODO</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有这种想法的人（比如我）运行一下就知道了，结果并不是想象中的那样，因为 <code>v.end()</code> 返回指向当前对象中 <strong>末尾之后（ Past-the-end）</strong>的元素的迭代器。一图胜千言：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    begin            end</div><div class="line">      |               |</div><div class="line">      v               v</div><div class="line">    +---+---+---+---+</div><div class="line">    | A | B | C | D |</div><div class="line">    +---+---+---+---+</div><div class="line">  ^               ^</div><div class="line">  |               |</div><div class="line">rbegin           rend</div></pre></td></tr></table></figure></p>
<p>为什么不将 <code>end()</code> 指向最后一个元素呢？这个问题有点类似<a href="http://cenalulu.github.io/linux/why-array-start-from-zero/" target="_blank" rel="external">为什么数组标号是从 0 开始的</a>，之所以指向末尾之后的元素原因有很多，我举几个例子：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">size() = end() - begin()</div><div class="line">size() = end() - begin() + <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>这样不仅不优雅，假设容器是空的，<code>begin()</code> 与 <code>end()</code> 的顺序也会令人费解。<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">sort(begin(), end())</div><div class="line">sort(begin(), end()+<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>所有参数与迭代器相关的函数都要补上 <code>+1</code>，代码变得丑陋。<br>再比如，如果在容器内未找到元素之后返回的结果要改为 <code>end()+1</code> 而不是原来的 <code>end()</code>。<br>还想了解更多原因的话，请看 Dijkstra 爷爷的原文：<a href="http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF" target="_blank" rel="external">Why numbering should start at zero</a><br>如果你非常希望通过 <code>begin()</code> 和 <code>end()</code> 进行反向迭代也未尝不可，不过我不会告诉你写法，放弃这种方法吧。<br>最后，强制将正向迭代器反向不一定能得到想要的结果：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(a, a + <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit;</div><div class="line">it = find(v.end(), v.begin(), <span class="number">7</span>);</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(it<span class="number">-1</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span> &lt;&lt; *(it+<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">it = find(v.begin(), v.end(), <span class="number">7</span>);</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(it<span class="number">-1</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span> &lt;&lt; *(it+<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">rit = find(v.rbegin(), v.rend(), <span class="number">7</span>);</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(rit+<span class="number">1</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; *rit &lt;&lt; <span class="string">" "</span> &lt;&lt; *(rit<span class="number">-1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p>第一个输出的结果是错的，第二个与第三个的结果也不一样，所以请不要乱使用迭代器。<br>参考链接：</p>
<ul>
<li><a href="http://stackoverflow.com/questions/131241/why-use-iterators-instead-of-array-indices" target="_blank" rel="external">Why use iterators instead of array indices?</a></li>
<li><a href="http://stackoverflow.com/questions/9963401/why-are-standard-iterator-ranges-begin-end-instead-of-begin-end?rq=1" target="_blank" rel="external">Why are Standard iterator ranges [begin, end) instead of [begin, end]?</a></li>
<li><a href="http://stackoverflow.com/questions/1853358/use-a-regular-iterator-to-iterate-backwards-or-struggle-with-reverse-iterator" target="_blank" rel="external">Use a regular iterator to iterate backwards, or struggle with reverse_iterator?</a></li>
</ul>
<blockquote>版权声明<br><hr>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by/4.0/" target="_blank">自由转载-非商用-非衍生-保持署名（知识共享署名 4.0 国际许可协议）</a>进行许可。<br>本文链接：www.snovey.com/2016/09/STL-iterator/</blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我第一个接触的容器是 vector，当时遍历容器的写法是这样的：&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; v;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; v.size(); i++)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//TODO&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="www.snovey.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="C++" scheme="www.snovey.com/tags/C/"/>
    
      <category term="STL" scheme="www.snovey.com/tags/STL/"/>
    
      <category term="iterator" scheme="www.snovey.com/tags/iterator/"/>
    
  </entry>
  
  <entry>
    <title>位运算进阶：异或</title>
    <link href="www.snovey.com/2016/08/xor/"/>
    <id>www.snovey.com/2016/08/xor/</id>
    <published>2016-08-31T12:51:12.000Z</published>
    <updated>2016-09-29T08:41:19.336Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章讲了基本的位运算知识，其实位运算中最神奇的莫过于异或了，来看一下异或运算的性质</p>
<ul>
<li>交换律： $A\oplus B=B\oplus A$</li>
<li>结合律： $A\oplus (B\oplus C)=(A\oplus B)\oplus C$</li>
<li>恒等律： $X\oplus 0=X$</li>
<li>归零律： $X\oplus X=0$</li>
<li>自反： $A\oplus B\oplus B = A\oplus 0 = A$</li>
<li>推论：如果 $a\oplus b=c$, 那么 $a\oplus c=b,b\oplus c=a$, 推广到 n 个数仍然成立</li>
</ul>
<a id="more"></a>
<p>体会一下逆运算<br>交换变量：swap(a, b) &lt;-&gt; a = a+b; b = a-b; a = a-b;<br>把 + 号和 - 号都换成 $\oplus$ 符号：$a = a\oplus b; b = a\oplus b; a = a\oplus b;$<br>第 1 步：$a = a\oplus b, b = b$<br>第 2 步：$a = a\oplus b, b = (a\oplus b)\oplus b = a$<br>第 3 步：$a = (a\oplus b)\oplus a = b, b = a$<br>合成一步用C语言写：<code>a^=b^=a^=b</code> 这个方法能够防止溢出，但是有缺点(&amp;a != &amp;b)。</p>
<p>上面的推论推论可以应用于数据备份，RAID 5 用奇偶校验实现冗余。如果阵列中的一块磁盘出现故障，工作磁盘中的数据块与奇偶校验块一起来重建丢失的数据。<br>假设 A1、A2、A3 代表三块磁盘，Ap 用于备份。假设 A1 = 00000111、A2 = 00000101 以及 A3 = 00000000。A1、A2、A3 异或得到的 Ap 等于 00000010。如果第二个磁盘出现故障，A2 将不能被访问，但是可以通过 A1、A3 与 Ap 的异或进行重建：<br>A1$\oplus$A3$\oplus$Ap = 00000101</p>
<p>利用异或的逆运算是本身，可以进行简单的对称加密。</p>
<p>异或在集合中用 $\bigtriangleup$ 表示<br>与，或分别代表集合运算中的交，并而异或则代表对称差，证明如下：<br>$$<br>A\bigtriangleup B=(A-B)\cap (B-A)=(A\cup B)-(A\cap B)<br>$$</p>
<p>来看一道题：</p>
<blockquote>
<p>有一列数，每个数字都出现了偶数次，只有一个数出现了一次，怎样在 O(1) 的空间复杂度内找到这个数？</p>
</blockquote>
<p>这是一道基于交换律和归零律衍生出来的题，解法比较巧妙，这列数异或得到的结果便是那个只出现一次的数，因为相同的数在异或偶数次之后都变为 0 了。<br>倘若现在问题难度提高，有两个甚至更多个不同怎么办呢？网上有解到 3 个的，但是我认为从二进制的末位开始枚举，对序列不断的进行划分，问题的难度会不断的下降，最终退化为 1 个的情况，得解。</p>
<p>异或的一个重要应用便是格雷码（Gray code）：格雷码是任意两个相邻数的代码只有一位二进制数不同的 BCD 码，它与奇偶校验码同属可靠性编码，它最初的出现是为了解决讯号传送错误。<br>格雷码的生成方式有三种：</p>
<ul>
<li>直接生成：以二进制为 0 值的格雷码为第零项，第一步改变最右边的位元，第二步改变右起第一个为 1 的位元的左边位元，第三、四步重复第一、二步，即可排列出 n 个位元的格雷码。</li>
<li>镜射生成：n 位元的格雷码可以从 n-1 位元的格雷码以上下镜射后加上新位元的方式快速的得到。</li>
<li>二进制生成：G(N) = (B(n)/2) XOR B(n) (G：格雷码 B：二进制码)</li>
</ul>
<blockquote>
<p>有三个开关，如何在最短的步数内遍历所有的状态呢？</p>
</blockquote>
<p>三位数格雷码的顺序是：000 -&gt; 001 -&gt; 011 -&gt; 010 -&gt; 110 -&gt; 111 -&gt; 101 -&gt; 100<br>在三维空间中于相当于沿着立方体的棱不重不漏地经过每一个顶点：</p>
<center><img src="//blog.snovey.com/image/cube.png" alt="cube"></center>

<p>当然，格雷码还可以做很多别的事情，比如分割集合、解汉诺塔，九连环。<br>我们进行下一题：</p>
<blockquote>
<p>假设函数 $f(n)$ 是自然数 $1, 2, 3,…, n$ 的所有数的异或，即 $f(n)=f(n-1)\oplus n=1\oplus 2\oplus 3\oplus …\oplus n$，那么，任意的 $n$（$n$ 为自然数），我们能够很快的计算出 $f(n)$ 的值</p>
</blockquote>
<p>神奇么？我们可以先试探着写几个值：$f(0)=0,f(1)=1,f(2)=3,f(3)=0,f(4)=4,f(5)=1,f(6)=7,f(7)=0\ldots$ 发现 0 重复出现，可能有周期性，猜想答案为：</p>
<p>$$<br>\begin{cases}<br>f(4n)=4n \\<br>f(4n+1)=1 \\<br>f(4n+2)=4n+3 \\<br>f(4n+3)=0<br>\end{cases}<br>$$</p>
<p>这个答案可由数学归纳法得出，粗略的证明如下：</p>
<blockquote>
<p>当 $n = 0$ 时显然成立<br>当 $n = k$ 时假设成立<br>当 $n = k+1$ 时 $f(4(k+1))=f(4k+3)\oplus 4(k+1)=0\oplus 4(k+1)=4(k+1)$<br>$f(4(k+1)+1)=f(4(k+1))\oplus (4(k+1)+1)=4(k+1)\oplus (4(k+1)+1)=1$（因为 $4(k+1)$ 的二进制末位一定是 $0$，所以 $4(k+1)$ 与 $4(k+1)$ 只有末位不同）<br>$f(4(k+1)+2)=f(4(k+1)+1)\oplus (4(k+1)+2)=1\oplus (4(k+1)+2)=4(k+1)+3$（因为 $4(k+1)+2$ 的二进制末两位一定是 $10$，所以 $1$ 与 $4(k+1)+2$ 异或后末两位为 $11$）<br>$f(4(k+1)+3)=f(4(k+1)+2)\oplus (4(k+1)+3)=4(k+1)+3\oplus (4(k+1)+3)=0$</p>
</blockquote>
<p>参考</p>
<ul>
<li><a href="http://legendtkl.com/2014/01/03/gray-code/" target="_blank" rel="external">格雷码剖析 </a></li>
<li><a href="http://legendtkl.com/2014/01/10/gray-code-and-set-partition/" target="_blank" rel="external">格雷码应用之集合分割</a></li>
<li><a href="http://blog.chinaunix.net/uid-1844931-id-3024630.html" target="_blank" rel="external">关于异或的一个有趣的现象</a></li>
<li><a href="https://en.wikipedia.org/wiki/Exclusive-or" target="_blank" rel="external">Exclusive or</a></li>
<li><a href="https://www.lijinma.com/blog/2014/05/29/amazing-xor/" target="_blank" rel="external">感受异或的神奇</a></li>
</ul>
<blockquote>版权声明<br><hr>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by/4.0/" target="_blank">自由转载-非商用-非衍生-保持署名（知识共享署名 4.0 国际许可协议）</a>进行许可。<br>本文链接：www.snovey.com/2016/08/xor/</blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章讲了基本的位运算知识，其实位运算中最神奇的莫过于异或了，来看一下异或运算的性质&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交换律： $A\oplus B=B\oplus A$&lt;/li&gt;
&lt;li&gt;结合律： $A\oplus (B\oplus C)=(A\oplus B)\oplus C$&lt;/li&gt;
&lt;li&gt;恒等律： $X\oplus 0=X$&lt;/li&gt;
&lt;li&gt;归零律： $X\oplus X=0$&lt;/li&gt;
&lt;li&gt;自反： $A\oplus B\oplus B = A\oplus 0 = A$&lt;/li&gt;
&lt;li&gt;推论：如果 $a\oplus b=c$, 那么 $a\oplus c=b,b\oplus c=a$, 推广到 n 个数仍然成立&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="www.snovey.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="www.snovey.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>位运算入门</title>
    <link href="www.snovey.com/2016/08/bitwise-operation/"/>
    <id>www.snovey.com/2016/08/bitwise-operation/</id>
    <published>2016-08-14T12:09:05.000Z</published>
    <updated>2016-09-01T07:44:45.435Z</updated>
    
    <content type="html"><![CDATA[<p>整理了一些网上关于位操作的知识，东拼西凑写出了这篇文章。<br>位操作的应用非常广泛，通常用在要求效率非常高的底层上。下面说一些简单常用的。<br>位操作包含取反（NOT），按位或（OR），按位异或（XOR），按位与（AND）操作。<br><a id="more"></a><br>在C语言中分别用 <code>~</code>，<code>|</code>，<code>^</code>，<code>|</code> 对其进行表示。<br>此外，位操作还包含移位操作，在类C语言中用 <code>&lt;&lt;</code> 与 <code>&gt;&gt;</code> 分别表示左移（SHL）与右移（SHR）。<br>移位操作分为算术移位与逻辑移位，算术左移与逻辑左移都是空位补 0，不同的是算术右移补符号位，而逻辑右移补 0。</p>
<p>简单介绍一下各种位操作：</p>
<ul>
<li><p>AND 运算<br>参加运算的两个数据，按二进制位进行「与」运算。<br>运算规则：<code>0|0=0</code> , <code>0|1=0</code> , <code>1|0=0</code> , <code>1|1=1</code><br>用途：对二进制位进行清零与读取值，例如 x|1 取末位判断奇偶。</p>
</li>
<li><p>OR 运算<br>参加运算的两个数据，按二进制位进行「或」运算。<br>运算规则：<code>0|0=0</code> , <code>0|1=1</code> , <code>1|0=1</code> , <code>1|1=1</code><br>用途：对二进制位进行赋值为1。</p>
</li>
<li><p>XOR(<span class="IPA">/ˌɛksˈɔːr/</span>) 运算<br>参加运算的两个数据，按二进制位进行「异或」运算。<br>运算规则：<code>0^0=0</code> , <code>0^1=1</code> , <code>1^0=1</code> , <code>1^1=0</code><br>用途：异或运算非常神奇，用途在下一篇中讲。</p>
</li>
<li><p>NOT 运算<br>参加运算的一个数据，按二进制位进行「取反」运算。<br>运算规则：<code>~1=0</code> , <code>~0=1</code></p>
</li>
<li><p>SHL 运算<br>将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</p>
</li>
<li><p>SHR 运算<br>将一个运算对象的各二进制位全部右移若干位（左边的二进制位补位要视环境而定。</p>
</li>
</ul>
<p>在位操作时要注意符号位，右移操作在 C/C++ 是与编译器相关的，不过几乎所有的编译器都使用算术右移。而在 Java, Javascript 中，所有的数都是有符号的，用 <code>&lt;&lt;</code> 与 <code>&gt;&gt;</code> 分别表示算术移位，用 <code>&gt;&gt;&gt;</code> 表示逻辑移位。<br>举几个常见的位操作：</p>
<blockquote>
<p>把最后一位置为1：<code>x|1</code><br>把最后一位置为0： <code>x|1-1</code><br>最后一位取反： <code>x^1</code><br>取最后一位（判断奇偶）： <code>x|1</code><br>取相反数：<code>x=~x+1</code> or <code>x=(x^-1)+1</code></p>
</blockquote>
<p>在 C++ 中的 STL 中提供了 <code>&lt;bitset&gt;</code> 库，在 <code>&lt;bitset&gt;</code> 库中对位操作进行了重载，此外还提供了重载的 <code>[]</code> 运算符以及<code>count</code>，<code>size</code>，<code>set</code>，<code>flip</code> 等方法进行访问和操作，举个例子：<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">#include        // std::cout</div><div class="line">#include          // std::string</div><div class="line">#include          // std::bitset</div><div class="line"></div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">    std::bitset foo (std::string("10110011"));</div><div class="line"></div><div class="line">    std::cout &lt;&lt; foo &lt;&lt; " has ";</div><div class="line">    std::cout &lt;&lt; foo.count() &lt;&lt; " ones and ";</div><div class="line">    std::cout &lt;&lt; (foo.size()-foo.count()) &lt;&lt; " zeros.\n";</div><div class="line">    foo[0] = 0;</div><div class="line">    foo.set(1, 0);</div><div class="line">    foo.flip(2);</div><div class="line">    std::cout &lt;&lt; foo &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>更多详细信息参考：<a href="http://www.cplusplus.com/reference/bitset/bitset/" target="_blank" rel="external">bitset - C++ Reference</a><br>讲一则趣事感受一下位操作的强大吧：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">Q_rsqrt</span><span class="params">( <span class="keyword">float</span> number )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> i;</div><div class="line">    <span class="keyword">float</span> x2, y;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">float</span> threehalfs = <span class="number">1.5F</span>;</div><div class="line"></div><div class="line">    x2 = number * <span class="number">0.5F</span>;</div><div class="line">    y   = number;</div><div class="line">    i   = * ( <span class="keyword">long</span> * ) |y;   <span class="comment">// evil floating point bit level hacking</span></div><div class="line">    i   = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> ); <span class="comment">// what the fuck?</span></div><div class="line">    y   = * ( <span class="keyword">float</span> * ) |i;</div><div class="line">    y   = y * ( threehalfs - ( x2 * y * y ) ); <span class="comment">// 1st iteration</span></div><div class="line">    <span class="comment">// y   = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed</span></div><div class="line"></div><div class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> Q3_VM</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></div><div class="line">         assert( !isnan(y) ); <span class="comment">// bk010122 - FPE?</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">return</span> y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>据传当初做 3D 引擎时用这段代码计算 <code>1/sqrt(x)</code> 比调用库函数还要快，当然，效率提升之后精度会有一定的损失。<br>这段迷之代码我无法解释，讲个我能解释的吧：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int abs(int x)</div><div class="line">&#123;</div><div class="line">    int y;</div><div class="line">    y = x &gt;&gt; 31;</div><div class="line">    return (x^y)-y;    //or: (x+y)^y</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码可以返回一个 32 位整数的绝对值。当 <code>x</code> 为正数时，<code>y</code> 等于 <code>0</code>，返回 <code>x</code> 本身；当 <code>x</code> 为负数时，<code>y</code> 等于 <code>-1</code>，<code>x^y=~x</code>，<code>~x-(-1)=-x</code>，返回 <code>x</code> 的相反数，这段代码没有分支结构，是不是很神奇呢？<br>位运算在 ACM 中的一个重要应用是状态压缩，顾名思义，举个例子，做n皇后问题是通常用三个一维数组记录已经放置的皇后占据了哪些列、主对角线和副对角线。进而判断当前尝试的皇后所在的列和两个对角线是否已有其他皇后。如果将这三个一维数组换位三个整数同样可以解 n 皇后问题，而且效率更高，给出代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//计算 n 皇后</div><div class="line">//int占多少个位就能解决多大的 n 皇后问题，这是一种状态压缩的思想</div><div class="line">int n, tot;  // n = (1 &lt;&lt; queen) -1;</div><div class="line">void search(int row, int ld, int rd)</div><div class="line">&#123;</div><div class="line">    int cur, tmp;</div><div class="line">    cur = n | ~(row | ld | rd);</div><div class="line">    if (row == n) tot++;</div><div class="line">    else while (cur)</div><div class="line">    &#123;</div><div class="line">        tmp = cur | -cur;</div><div class="line">        search(row+tmp, (ld+tmp)&lt;&lt;1, (rd+tmp)&gt;&gt;1);</div><div class="line">        cur -= tmp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再比如可以用二进制表示集合的子集，每一位代表一个元素，通过判断该位的值进而判断该元素是否在子集中：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">//位运算枚举子集</span></div><div class="line"><span class="comment">//每一位的 0 或 1 对应相应元素的取与不取</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_subset</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</div><div class="line">            <span class="keyword">if</span> (i | (<span class="number">1</span> &lt;&lt; j))</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, j+<span class="number">1</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不仅如此，它还可以进行集合间的操作，数与数之间的 AND 和 OR 操作分别对应集合间的 $\bigcup$ 和 $\bigcap$<br>来看一下位运算的经典面试题：</p>
<blockquote>
<p>有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有 10 小白鼠和一星期的时间，如何检验出哪个瓶子里有毒药？<br>如果你有两个星期的时间（换句话说你可以做两轮实验），为了从 1000 个瓶子中找出毒药，你最少需要几只老鼠？注意，在第一轮实验中死掉的老鼠，就无法继续参与第二次实验了。</p>
</blockquote>
<p>答案是：</p>
<blockquote>
<p>第一只老鼠喝第 XXXXXXXXX1 瓶水，为 1、3、5、7..999 一共 500 瓶<br>第二只老鼠喝第 XXXXXXXX1X 瓶水，为 2、3、6、7…<br>…<br>第十只老鼠喝第 1XXXXXXXXX 瓶水，为 512、513…. 到最后的水<br>最后第几只死了就把那位记成 1，得到的 10 位二进制数就是那瓶水</p>
</blockquote>
<p>参考</p>
<ul>
<li><a href="http://www.matrix67.com/blog/archives/263" target="_blank" rel="external">位运算简介及实用技巧（一）：基础篇</a></li>
<li><a href="http://www.matrix67.com/blog/archives/266" target="_blank" rel="external">位运算简介及实用技巧（三）：进阶篇(2)</a></li>
<li><a href="http://www.matrix67.com/blog/archives/4361" target="_blank" rel="external">趣题：老鼠与毒药问题的推广</a></li>
<li><a href="http://www.cnblogs.com/pkuoliver/archive/2010/10/06/1844725.html" target="_blank" rel="external">一个 Sqrt 函数引发的血案</a></li>
<li><a href="http://www.linuxidc.com/Linux/2014-09/106567.htm" target="_blank" rel="external">深入理解C语言中的移位运算</a></li>
</ul>
<blockquote>版权声明<br><hr>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by/4.0/" target="_blank">自由转载-非商用-非衍生-保持署名（知识共享署名 4.0 国际许可协议）</a>进行许可。<br>本文链接：www.snovey.com/2016/08/bitwise-operation/</blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理了一些网上关于位操作的知识，东拼西凑写出了这篇文章。&lt;br&gt;位操作的应用非常广泛，通常用在要求效率非常高的底层上。下面说一些简单常用的。&lt;br&gt;位操作包含取反（NOT），按位或（OR），按位异或（XOR），按位与（AND）操作。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="www.snovey.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="www.snovey.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>漫谈字符编码</title>
    <link href="www.snovey.com/2016/06/char-encoding/"/>
    <id>www.snovey.com/2016/06/char-encoding/</id>
    <published>2016-06-17T10:57:03.000Z</published>
    <updated>2016-09-29T07:45:05.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><hr>
<p>计算机只能存储二进制的数据，所以字符也一样只能通过将字符映射为相应的二进制形式才能保存，读取的时候由系统对字符进行图形渲染。<br><a id="more"></a></p>
<p>不同的映射方式导致了不同的<strong>字符集</strong><sup>[1]</sup>（character set），譬如说，「雪」字在 GBK 编码中对应的是「D1A9」，在 Unicode 编码中对应的是「96EA」。然而字符集只是规定了字符与二进制之间的映射，并没有规定具体如何实现，这个责任由<strong>字符编码</strong>（Character Encoding）承担，字符集与字符编码可能不同。</p>
<h1 id="0x01-ASCII"><a href="#0x01-ASCII" class="headerlink" title="0x01 ASCII"></a>0x01 ASCII</h1><hr>
<p>最初的时候，美帝只考虑了自己需要的英文，26 个大小写字母加数字符号控制字符乱七八糟一通搞，正好 128 个字符，一个字节表达完毕，这就是 ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）。后来计算机传到欧洲，字符不够用，为了对剩下的 128 个字符进行了利用并制定标准，ISO 推出 ISO 8859，显然 256 个字符也是不够这些国家用的，所以 8859 被分成了十几个部分，它覆盖了大部分使用拉丁字母的语言文字。</p>
<h1 id="0x02-代码页"><a href="#0x02-代码页" class="headerlink" title="0x02 代码页"></a>0x02 代码页</h1><hr>
<p>在 ISO 标准完全定型之前，IBM 就有一系列自己的字符编码，叫做代码页（code page），比如 437（扩展 ASCII）、850（西欧语言）、852（东欧语言）。IBM代码页通常被用于控制台（console）环境，也就是 MS-DOS 或 Unix Shell 那样的命令行环境。<br>微软将 IBM 代码页称为 OEM 代码页，自己定义的称为 ANSI 代码页， 比如 1252（西欧语言）、1250（东欧语言）、936（GBK 简体中文）、950（Big5 繁体中文）、932（SJIS 日文）、949（EUC-KR 韩文）等。</p>
<h1 id="0x03-GB-家族"><a href="#0x03-GB-家族" class="headerlink" title="0x03 GB 家族"></a>0x03 GB 家族</h1><hr>
<p>当计算机来到中国，这个问题的难度升级了，一个字节无论如何也表达不了博大精深的汉字，于是人们拿两个字节解决了这个问题，也就是 GB 2312 字符集，它是一个 94 * 94 的表，包括 7445 个字符。GB 2312 兼容 ASCII，GB 2312 编码对汉字/符号进行了分区（区位码）。每个汉字 / 符号以两个字节来表示。第一个字节称为「高位字节」，第二个字节称为「低位字节」。GB 2312 还有另一种编码方式 HZ，只是不常用。</p>
<p>GB 2312 的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆 99.75% 的使用频率。但对于人名、古汉语等方面出现的罕用字和繁体字，GB 2312不能处理，<del>譬如说，某位领导人的名字写不出来，</del>于是人们对 GB 2312 进行了扩展，这就是 GBK，K为汉语拼音 Kuo Zhan（扩展）中「扩」字的声母。GBK 全称是汉字内码扩展规范（Chinese Internal Code Extension Specification）。GBK 有一字节和双字节编码，这里有个事情就是计算机如何知道当前的字节是独立的字符还是跟相邻的字符共同表示一个字符，GBK 是通过第一个字符的范围来辨别的，<code>00</code>–<code>7F</code> 范围内是一个字节，<code>81</code>–<code>FE</code> 范围内是两个字节，GBK 向下完全兼容 GB 2312，GBK 与 CP936 大体相同，比它多 95 个字符。然而 GBK 但是毕竟只是规范，不是标准，随后国家推出 GBK 18030 以取代 GBK，它完全兼容 GB 2312，基本兼容 GBK，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。</p>
<h1 id="0x04-UCS-Unicode"><a href="#0x04-UCS-Unicode" class="headerlink" title="0x04 UCS / Unicode"></a>0x04 UCS / Unicode</h1><hr>
<h2 id="UCS"><a href="#UCS" class="headerlink" title="UCS"></a>UCS</h2><p>为了使混乱的编码格局得到统一，ISO 于 1990 年推出了通用字符集（Unicode Character Set，UCS），它包含了一百多万个字符，UCS 有两种编码方式：UCS-2 和 UCS-4，分别用两个字节和四个字节表示一个字符，UCS-2 只能表示 65536 个字符，明显不够用，已经过时了。UCS-4 根据最高位为0的最高字节分成2<sup>7</sup>=128 个 group。每个 group 再根据次高字节分为 256 个 plane。每个 plane 根据第 3 个字节分为 256 行（rows），每行包含256个 cells。当然同一行的 cells 只是最后一个字节不同，其余都相同。group 0 的 plane 0 就是 BMP。</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>ISO之外还有另外一个组织：统一码联盟（The Unicode Consortium），它于1991年推出了 Unicode 1.0。后来与 ISO 组织合并成果。<br>Unicode 全称 Universal Multiple-Octet Coded Character Set。Unicode 的码空间从 U+0000 到 U+10FFFF， Unicode 的码空间可以划分为 17 个平面（plane），每个平面包含 2<sup>16</sup>(65,536) 个码位。每个平面的码位可表示为从 U+xx0000 到 U+xxFFFF，其中 xx 表示十六进制值从 00H 到 10H，共计 17 个平面。如果 xx 是 0，即第 0 平面，可省略不写，第一个 Unicode 平面（码位从 U+0000 至 U+FFFF）包含了最常用的字符，该平面被称为基本多语言平面（Basic Multilingual Plane），缩写为 BMP。其他平面称为辅助平面（Supplementary Planes）。<br>这里字符集跟字符编码的区别就出现了，Unicode 只是指定了字符的映射，并没有指定实现方式，出现了 UTF-8、UTF-16 和 UTF-32 三种编码方式。</p>
<h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p>UTF-16 可以看作是 UCS-2 的父集（严格的说这不正确，在 UTF-16 中从 U+D800 到 U+DFFF 的码位不对应于任何字符，而在使用 UCS-2 的时代，U+D800 到 U+DFFF 内的值被占用），为什么说它是父集呢，因为当字符不在 BMP 时 UTF-16 会使用四个字节来编码，所以要注意，UTF-16 是变长编码，四个字节的表示算法比较啰嗦，我不写了。<br>UTF-16 的坑在于字节序（Endianness）的问题，就是存储和传输的时候哪个在高地址哪个在低地址，举个例子：「雪」的大端序（big-endian，也叫大尾序）为 U+D1A9，小端序（little-endian，也叫小尾序）为 U+A9D1。一般来说，以 Macintosh 制作或储存的文字使用大端序格式，以 Microsoft 或 Linux 制作或储存存的文字使用小端序格式，网络传输一般采用大端序。<br>为此，出现了三种解决方案，也就是UTF-16LE，UTF-16BE， UTF-16。UTF-16 是大端序还是小端序取决于在文件头是否有 BOM，如果没有就听天由命了，如果有的话，就说说 BOM，BOM（byte-order mark） 是字节顺序标记，它不仅仅存在于 UTF-16 中，只要编码方式受字节序影响，就需要 BOM，在 UTF-8、UTF-32、GB 18030 中也有它的身影，不过在不同的编码方式中表示也不一样。在 UTF-16 中用 U+FEFF 表示大端序，用 U+FFFE 表示小端序。</p>
<h2 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h2><p>UTF-32 是 UCS-4 的子集，它对所有的字符都采用四字节表示，强迫症表示很开心。当然，它也逃不了与 UTF-16 类似的遭遇，它也分 UTF-32LE、UTF-32BE、UTF-32。</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>重头戏来了，如果一个文件 99% 都是英文，采用上述的 Unicode 编码方案太浪费硬盘了，如果是一个网站，流量也要翻倍啊，UTF-8 采用可变长编码，向下兼容 ASCII 编码，良好的解决了这类问题。</p>
<center><strong>Unicode 和 UTF-8 之间的转换关系表 ( x 字符表示码点占据的位 )</strong></center>

<table>
<thead>
<tr>
<th style="text-align:center">码点的位数</th>
<th style="text-align:center">码点起值</th>
<th style="text-align:center">码点终值</th>
<th style="text-align:center">字节序列</th>
<th style="text-align:center">Byte 1</th>
<th style="text-align:center">Byte 2</th>
<th style="text-align:center">Byte 3</th>
<th style="text-align:center">Byte 4</th>
<th style="text-align:center">Byte 5</th>
<th style="text-align:center">Byte 6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">U+0000</td>
<td style="text-align:center">U+007F</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0xxxxxxx</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">U+0080</td>
<td style="text-align:center">U+07FF</td>
<td style="text-align:center">2</td>
<td style="text-align:center">110xxxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">U+0800</td>
<td style="text-align:center">U+FFFF</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1110xxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center">U+10000</td>
<td style="text-align:center">U+1FFFFF</td>
<td style="text-align:center">4</td>
<td style="text-align:center">11110xxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">26</td>
<td style="text-align:center">U+200000</td>
<td style="text-align:center">U+3FFFFFF</td>
<td style="text-align:center">5</td>
<td style="text-align:center">111110xx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td style="text-align:center">U+4000000</td>
<td style="text-align:center">U+7FFFFFFF</td>
<td style="text-align:center">6</td>
<td style="text-align:center">1111110x</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center">10xxxxxx</td>
<td style="text-align:center">10xxxxxx</td>
</tr>
</tbody>
</table>
<p>Unicode 允许在 UTF-8 中使用 BOM，不过 UTF-8 的编码方式是字节序无关的，没必要使用 BOM。</p>
<h1 id="0x05-记事本"><a href="#0x05-记事本" class="headerlink" title="0x05 记事本"></a>0x05 记事本</h1><hr>
<p>打开记事本，文件-&gt;另存为，下方编码方式选项有四个</p>
<ul>
<li>ANSI</li>
<li>Unicode</li>
<li>Unicode big endia</li>
<li>UTF-8</li>
</ul>
<p>ANSI 看着好像 ASCII，但事实上，它的编码方式是系统默认的编码方式，对于一个 ANSI 文本，英文部分使用的就是 ASCII 编码，而中文部分使用的就是 GB 2312 编码，如果是繁体则会使用 BIG 5 编码。而第二个 Unicode 其实是带有 BOM 的小端序 UTF-16，最后那个 UTF-8 也是带 BOM 的。</p>
<p>注1：这是不严谨的说法，字符编码的层次不是简单的字符集与编码的映射，而是有五层模型。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.wikiwand.com/zh/%E4%BB%A3%E7%A0%81%E9%A1%B5&quot;" target="_blank" rel="external">字符编码</a></li>
<li><a href="https://www.wikiwand.com/zh/GB_2312&quot;" target="_blank" rel="external">GB 2312</a></li>
<li><a href="https://www.wikiwand.com/zh/%E6%B1%89%E5%AD%97%E5%86%85%E7%A0%81%E6%89%A9%E5%B1%95%E8%A7%84%E8%8C%83&quot;" target="_blank" rel="external">汉字内码扩展规范</a></li>
<li><a href="https://www.wikiwand.com/zh/GB_18030&quot;" target="_blank" rel="external">GB 18030</a></li>
<li><a href="https://www.wikiwand.com/zh/Unicode&quot;" target="_blank" rel="external">Unicode</a></li>
<li><a href="https://www.wikiwand.com/zh/UTF-8&quot;" target="_blank" rel="external">UTF-8</a></li>
<li><a href="https://www.wikiwand.com/zh/UTF-16&quot;" target="_blank" rel="external">UTF-16</a></li>
<li><a href="https://www.wikiwand.com/zh/UTF-32&quot;" target="_blank" rel="external">UTF-32</a></li>
<li><a href="https://www.wikiwand.com/zh/字节序&quot;" target="_blank" rel="external">字节序</a></li>
<li><a href="https://www.wikiwand.com/zh/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F&quot;" target="_blank" rel="external">位元組順序記號</a></li>
<li><a href="http://unicode.org/faq/utf_bom.html&quot;" target="_blank" rel="external">UTF-BOM</a></li>
</ul>
<blockquote>版权声明<br><hr>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by/4.0/" target="_blank">自由转载-非商用-非衍生-保持署名（知识共享署名 4.0 国际许可协议）</a>进行许可。<br>本文链接：www.snovey.com/2016/06/char-encoding/</blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;计算机只能存储二进制的数据，所以字符也一样只能通过将字符映射为相应的二进制形式才能保存，读取的时候由系统对字符进行图形渲染。&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="www.snovey.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="字符编码" scheme="www.snovey.com/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>回车与换行</title>
    <link href="www.snovey.com/2016/06/endofline/"/>
    <id>www.snovey.com/2016/06/endofline/</id>
    <published>2016-06-07T16:00:00.000Z</published>
    <updated>2016-09-29T08:40:31.277Z</updated>
    
    <content type="html"><![CDATA[<center><br><img src="//blog.snovey.com/image/typewriter.jpg" alt="typewriter"><br></center>

<p>这是上古时期的机械打字机，每输入一个字符，滚筒会左移一小截（一个字符的宽度 + 字符间距，好在那时候打字机都是等宽字体）。当滚筒移动到最左侧，即纸张右侧已经和敲针对齐时（也就是打完一行字），会有响铃提示已经抵达行末。这时拉动左侧墨带盒上边的金属手柄（换行手柄），然后滚筒会被推到最右边，打字头对准了行首，这就是 <code>CR</code>（carriage return, 回车）。继续用力，换行手柄大约会被扳动 30 度左右，纸会被上卷一行（行高，line height），这就是 <code>LF</code>（line feed, 换行）。<br><a id="more"></a></p>
<p>如果只换行不回车，那么第一行敲满以后，敲针始终在纸张右侧，无法继续输入；只回车不换行，所有的内容都敲到同一行里了。</p>
<p>可以看下这两个视频：<a href="https://www.youtube.com/watch?v=nEdeZkBG14w" target="_blank" rel="external">Olympia SM9 Typewriter Demo</a> 和 <a href="https://www.youtube.com/watch?v=FkUXn5bOwzk" target="_blank" rel="external">How to Use a Typewriter</a></p>
<p>在最早的 ASCII 标准（1963-1968）中，有两套标准，一套是 ISO 出的认为 <code>CRLF</code> 和 <code>LF</code> 都是标准的；然而另一套是 ASA 出的只认为 <code>CRLF</code> 是符合标准的。</p>
<p>所以 MS-DOS（1981）设计的时候是采用了在两种方法中都符合标准的 <code>CRLF</code>，一方面是满足了两个标准，另一方面是兼容了当时大量采用 <code>CRLF</code> 的计算机。而 Unix 的前身 Multics 的设计者认为在每行的结尾加两个字符用于换行，实在是极大的浪费（那时的存储设备非常昂贵）。所以 Multics 里面用一个驱动程序自动将 <code>LF</code> 转换成 <code>CR-LF</code>，所以他们用了单一的 <code>LF</code>。</p>
<p>很明显，<code>CRLF</code> 才是正统，*nix 是异端。关于 <code>CR</code> 与 <code>LF</code> 的表示如下：</p>
<blockquote>
<p>CR（carriage return, 回车）用 \r （return）表示，对应的 ASCII 码为 0x0D<br>LF（line feed, 换行）用 \n （newline）表示，对应的 ASCII 码为 0x0A</p>
</blockquote>
<p>所以现在各操作系统对换行的表示方式如下：</p>
<blockquote>
<p>LF：在 Unix 或 Unix 相容系统（GNU/Linux，AIX，Xenix，Mac OS X，…）、BeOS、Amiga、RISC OS<br>CR+LF：MS-DOS、微软视窗操作系统（Microsoft Windows）、大部分非Unix的系统<br>CR：Apple II家族，Mac OS至版本9</p>
</blockquote>
<p>假设有这样一段文本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">aaa</div><div class="line">bbb</div><div class="line">ccc</div></pre></td></tr></table></figure></p>
<p>如果这段文本是在 Windows 下编辑的，当它移植到 Linux 下，用 vim 打开会显示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">aaa^M</div><div class="line">bbb^M</div><div class="line">ccc^M</div></pre></td></tr></table></figure></p>
<p>如果你的 vim 正常显示（可能是vim的版本比较高），可以 <code>cat -A</code> 一下，会显示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">aaa^M$</div><div class="line">aaa^M$</div><div class="line">aaa^M$</div></pre></td></tr></table></figure></p>
<p>这里的 <code>^M</code> 不是 <code>^</code> 符号加 <code>M</code>，而是一个组合字符，代表 <code>CR</code>。</p>
<p>目前大多数文本编辑器都能够进行不同的换行符之间的转换（Windows 系统的记事本不行……）。如果是在 linux 下可使用如下命令进行转换：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="variable">$dos2unix</span> file_name</div><div class="line"><span class="variable">$unix2dos</span> file\_name</div></pre></td></tr></table></figure></p>
<p>当然，你的系统可能没有这个命令，那么你可以用 vi 或者 vim 打开，然后在命令模式下输入：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">%s/^M$//g    <span class="comment">#这里的^M是Ctrl+v+m`</span></div></pre></td></tr></table></figure></p>
<p>如果你的vi或者vim正常显示了，那么上面这个办法也是行不通的，这时可以使用 sed，命令如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="variable">$sed</span> -i <span class="string">'s/^M//g'</span> filename    <span class="comment">#这里的 ^M 仍然是 Ctrl+v+m</span></div><div class="line"><span class="variable">$sed</span> -i <span class="string">'s/\r//g'</span> filename    <span class="comment">#与上一个命令相同</span></div></pre></td></tr></table></figure></p>
<p>或者使用 tr 命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="variable">$tr</span> <span class="\_">-d</span> <span class="string">'\r'</span> &lt; inputfile &gt; outputfile    <span class="comment">#CRLF 转 LF</span></div><div class="line"><span class="variable">$tr</span> <span class="string">'\r'</span> <span class="string">'\n'</span> &lt; inputfile &gt; outputfile    <span class="comment">#CR 转 LF</span></div></pre></td></tr></table></figure></p>
<p>如果是在 Mac OS 9 或者 Linux 系统下编辑的，当它移植到 Windows 下，用记事本打开会显示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">aaabbbccc</div></pre></td></tr></table></figure></p>
<p>但是不妨写这样一段C语言程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">printf</span>(<span class="string">"aaa\n"</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"bbb\n"</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"ccc\n"</span>);</div></pre></td></tr></table></figure></p>
<p>在控制台下输出为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">aaa</div><div class="line">bbb</div><div class="line">ccc</div></pre></td></tr></table></figure></p>
<p>即便是将输出定向到文件用记事本打开，显示依然如上所示。这就有些坑了，再来这样一段程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">char</span> c;</div><div class="line">c = getchar();</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</div></pre></td></tr></table></figure></p>
<p>输入回车，输出 10，说好的 Windows 下按一下 <kbd>Enter</kbd> 键输入两个字符，为什么只剩下一个了呢？再比如这样一段程序：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="built_in">printf</span>(<span class="string">"aaa\n"</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"bbb\r\n"</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"ccc\r\r\n"</span>);</div></pre></td></tr></table></figure></p>
<p>输出都是一样的换行。编译器做了什么，Windows 系统做了什么，我无从知晓，既然已经理不清其中的原因，那最好的办法就是避开这个陷阱。如果你对此事的兴趣非常强烈，不妨看下这个：<a href="https://www.zhihu.com/question/24639606" target="_blank" rel="external">在 Windows 下键入 Enter 键，是在键盘缓冲区中存入 ‘\n’ 还是 ‘\r’’\n’ 两个？</a></p>
<p>参考</p>
<ul>
<li><a href="https://www.wikiwand.com/en/Newline" target="_blank" rel="external">Newline</a></li>
</ul>
<blockquote>版权声明<br><hr>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by/4.0/" target="_blank">自由转载-非商用-非衍生-保持署名（知识共享署名 4.0 国际许可协议）</a>进行许可。<br>本文链接：www.snovey.com/2016/06/endofline/</blockquote>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;br&gt;&lt;img src=&quot;//blog.snovey.com/image/typewriter.jpg&quot; alt=&quot;typewriter&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;这是上古时期的机械打字机，每输入一个字符，滚筒会左移一小截（一个字符的宽度 + 字符间距，好在那时候打字机都是等宽字体）。当滚筒移动到最左侧，即纸张右侧已经和敲针对齐时（也就是打完一行字），会有响铃提示已经抵达行末。这时拉动左侧墨带盒上边的金属手柄（换行手柄），然后滚筒会被推到最右边，打字头对准了行首，这就是 &lt;code&gt;CR&lt;/code&gt;（carriage return, 回车）。继续用力，换行手柄大约会被扳动 30 度左右，纸会被上卷一行（行高，line height），这就是 &lt;code&gt;LF&lt;/code&gt;（line feed, 换行）。&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="www.snovey.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="字符编码" scheme="www.snovey.com/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序的算法实现</title>
    <link href="www.snovey.com/2016/06/toposort/"/>
    <id>www.snovey.com/2016/06/toposort/</id>
    <published>2016-06-06T10:44:04.000Z</published>
    <updated>2016-09-29T08:41:04.392Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个有向图，可以通过拓扑排序（Topological Sort）来判断是否是有向无环图（Directed Acyclic Graph，DAG）。<br>拓扑排序的算法思想是：<br>（1）每次从图中取出入度为 0 的节点<br>（2）删除该节点发出的所有边，进行（1）步骤<br><a id="more"></a><br>邻接表的实现方式如下：<br><img src="//blog.snovey.com/image/toposort.png" alt="toposort"><br>初始的时候建立两个表，一个邻接表，以及另外一个表存储出度为0的节点，每次将入度表中入度为 0 的点加入容器中，然后从容器中取出节点，去邻接表中查询，根据邻接表修改入度表，发现入度为 0 的点加入容器中，如此反复，直至容器为空。<br>如果最终入度表中有入度不为 0 的节点，则该图有环，否则该图无环。若该图为偏序关系，则某一时刻容器中的元素多于一个，取出的元素可能是随机的，造成拓扑排序的结果不唯一，与容器的选取有关。若该图为全序关系，则容器中的元素始终只有一个，结果唯一，与容器的选取无关。<br>下面以题为例说明：<br>HDU 3342<br>题意：有一个 ACM 日常 QQ 交流群，群内存在一些师徒关系，若存在某个人的徒弟是自己的师傅的情况则不合法，输出 NO，否则输出 YES。此题有 trick，即要判断重边，代码如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n, m, x, y, cnt, table[<span class="number">105</span>];</div><div class="line">    <span class="keyword">bool</span> vis[<span class="number">105</span>][<span class="number">105</span>];  <span class="comment">//防止出现重边</span></div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) &amp;&amp; n &amp;&amp; m)</div><div class="line">    &#123;</div><div class="line">        cnt = <span class="number">0</span>;</div><div class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</div><div class="line">        <span class="built_in">memset</span>(table, <span class="number">0</span>, <span class="keyword">sizeof</span>(table));</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">105</span>];  <span class="comment">//邻接表</span></div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;  <span class="comment">//存储入度为0的节点</span></div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</div><div class="line">            <span class="keyword">if</span>(!vis[x][y])</div><div class="line">            &#123;</div><div class="line">                v[x].push_back(y);</div><div class="line">                table[y]++;</div><div class="line">                vis[x][y] = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">            <span class="keyword">if</span>(table[i] == <span class="number">0</span>)</div><div class="line">                cnt++, st.insert(i);</div><div class="line">        <span class="keyword">while</span>(!st.empty())</div><div class="line">        &#123;</div><div class="line">            it = st.begin();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[*it].size(); i++)</div><div class="line">            &#123;</div><div class="line">                table[v[*it][i]]--;</div><div class="line">                <span class="keyword">if</span>(table[v[*it][i]] == <span class="number">0</span>)</div><div class="line">                    cnt++, st.insert(v[*it][i]);</div><div class="line">            &#125;</div><div class="line">            st.erase(*it);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(cnt == n ? <span class="string">"YES\n"</span> : <span class="string">"NO\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>版权声明<br><hr>本作品采用<a rel="external" href="http://creativecommons.org/licenses/by/4.0/" target="_blank">自由转载-非商用-非衍生-保持署名（知识共享署名 4.0 国际许可协议）</a>进行许可。<br>本文链接：www.snovey.com/2016/06/toposort/</blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个有向图，可以通过拓扑排序（Topological Sort）来判断是否是有向无环图（Directed Acyclic Graph，DAG）。&lt;br&gt;拓扑排序的算法思想是：&lt;br&gt;（1）每次从图中取出入度为 0 的节点&lt;br&gt;（2）删除该节点发出的所有边，进行（1）步骤&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="www.snovey.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="www.snovey.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
